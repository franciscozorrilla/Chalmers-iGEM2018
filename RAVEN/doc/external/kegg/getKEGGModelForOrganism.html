<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of getKEGGModelForOrganism</title>
  <meta name="keywords" content="getKEGGModelForOrganism">
  <meta name="description" content="getKEGGModelForOrganism">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">external</a> &gt; <a href="index.html">kegg</a> &gt; getKEGGModelForOrganism.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for external\kegg&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>getKEGGModelForOrganism
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>getKEGGModelForOrganism</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function model=getKEGGModelForOrganism(organismID,fastaFile,dataDir,outDir,keepUndefinedStoich,keepIncomplete,keepGeneral,cutOff,minScoreRatioG,minScoreRatioKO,maxPhylDist,nSequences,seqIdentity) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> getKEGGModelForOrganism
   Reconstructs a genome-scale metabolic model based on protein homology to the
   orthologies in KEGG

   organismID          three or four letter abbreviation of the organism
                       (as used in KEGG). If not available, use a closely
                       related species. This is used for determing the
                       phylogenetic distance. Use 'eukaryotes' or
                       'prokaryotes' to get a model for the whole domain.
                       Only applicable if fastaFile is empty, i.e. no
                       homology search should be performed
   fastaFile           a FASTA file that contains the protein sequences of
                       the organism for which to reconstruct a model (opt,
                       if no FASTA file is supplied then a model is
                       reconstructed based only on the organism
                       abbreviation. This option ignores all settings
                       except for keepUndefinedStoich, keepIncomplete and
                       keepGeneral)
   dataDir             directory for which to retrieve the input data.
                       Should contain a combination of these sub-folders:
                       -dataDir\keggdb
                           The KEGG database files used in 1a (see below)
                       -dataDir\fasta
                           The multi-FASTA files generated in 1b (see
                           below)
                       -dataDir\aligned
                           The aligned FASTA files as generated in 2a (see
                           below)
                       -dataDir\hmms
                           The hidden Markov models as generated in 2b or
                           downloaded from BioMet Toolbox (see below)
                       The final directory in dataDir should be styled as
                       proXXX_keggYY or eukXXX_keggYY, indicating whether
                       the HMMs were trained on pro- or eukaryotic
                       sequences, using a sequence similarity threshold of
                       XXX %, fitting the KEGG version YY. E.g.
                       euk100_kegg82. (opt, see note about fastaFile. Note
                       that in order to rebuild the KEGG model from a
                       database dump, as opposed to using the version
                       supplied with RAVEN, you would still need to supply
                       this)
   outDir              directory to save the results from the quering of
                       the hidden Markov models. The output is specific
                       for the input sequences and the settings used. It
                       is stored in this manner so that the function can
                       continue if interrupted or if it should run in
                       parallel. Be careful not to leave output files from
                       different organisms or runs with different settings
                       in the same folder. They will not be overwritten
                       (opt, default is a temporary dir where all *.out
                       files are deleted before and after doing the
                       reconstruction)
   keepUndefinedStoich    include reactions in the form n A &lt;=&gt; n+1 A. These
                       will be dealt with as two separate metabolites
                       (opt, default true)
   keepIncomplete      include reactions which have been labelled as
                       &quot;incomplete&quot;, &quot;erroneous&quot; or &quot;unclear&quot; (opt,
                       default true)
   keepGeneral         include reactions which have been labelled as
                       &quot;general reaction&quot;. These are reactions on the form
                       &quot;an aldehyde &lt;=&gt; an alcohol&quot;, and are therefore
                       unsuited for modelling purposes. Note that not all
                       reactions have this type of annotation, and the
                       script will therefore not be able to remove all
                       such reactions (opt, default false)
   cutOff              significance score from HMMer needed to assign
                       genes to a KO (opt, default 10^-50)
   minScoreRatioG      a gene is only assigned to KOs for which the score
                       is &gt;=log(score)/log(best score) for that gene. This
                       is to prevent thata gene which clearly belongs to
                       one KO is assigned also to KOs with much lower
                       scores (opt, default 0.8 (lower is less strict))
   minScoreRatioKO     ignore genes in a KO if their score is
                       &lt;log(score)/log(best score in KO). This is to
                       &quot;prune&quot; KOs which havemany genes and where some are
                       clearly a better fit (opt, default 0.3 (lower is
                       less strict))
   maxPhylDist         -1: only use sequences from the same domain
                       (Prokaryota, Eukaryota)
                       other (positive) value: only use sequences for
                       organisms where the phylogenetic distance is at the
                       most this large (as calculated in getPhylDist)
                       (opt, default Inf, which means that all sequences
                       will be used)
   nSequences          for each KO, use up to this many sequences from the
                       most closely related species. This is mainly to
                       speed up the alignment process for KOs with very
                       many genes. This subsampling is performed before
                       running CD-HIT (opt, default inf)
   seqIdentity         sequence identity threshold in CD-HIT, referred as
                       &quot;global sequence identity&quot; in CD-HIT User's Guide.
                       The only possible options are 1 (100 %), 0.9 (90 %)
                       and 0.5 (50 %). If other values are provided,
                       CD-HIT is skipped (opt, default -1, i.e. CD-HIT is
                       skipped)

   model               the reconstructed model

   PLEASE READ THIS: The input to this function can be confusing, because
   it is intended to be run in parallel on a cluster or in multiple
   sessions. It therefore saves a lot of intermediate results to storage.
   This also serves the purpose of not having to do redundant
   calculations. This, however, comes with the disadvantage of somewhat
   trickier handling. This is what this function does:

   1a. Loads files from a local KEGG FTP dump and constructs a general
       RAVEN model representing the metabolic network. KEGG FTP access
       requires a &lt;a href=&quot;matlab:
       web('http://www.bioinformatics.jp/en/keggftp.html')&quot;&gt;license&lt;/a&gt;.
   1b. Generates FASTA files from the KEGG FTP dump (see 1a). One
       multi-FASTA file for each KO in KEGG is generated. Make sure you
       actually need these first, as the parsing is time-consuming (see
       below).

   These steps only have to be re-done every time KEGG updates their
   database (or rather when the updates are large enough to warrant
   rerunning this part). Many user would probably never use this feature.

   2a. Does alignment of the multi-FASTA files for future use. This uses
       the settings &quot;useEvDist&quot; and &quot;nSequences&quot; to control which
       sequences should be used for constructing Hidden Markov models
       (HMMs), and later for matching your sequences to.
   2b. Trains hidden Markov models using HMMer for each of the aligned
       FASTA files.

   The most common alternatives here would be to use sequences from only
   eukaryotes, only prokaryotes or all sequences in KEGG. As explained in
   the README.md file, various sets of pre-trained hidden Markov models are
   available at &lt;a href=&quot;matlab:
   web('http://biomet-toolbox.chalmers.se/index.php?page=downtools-raven')&quot;&gt;BioMet
   Toolbox&lt;/a&gt;. This is normally the most convenient way, but if you would
   like to use, for example, only fungal sequences for training the HMMs
   then you need to run this part.

   3a. Queries the HMMs with sequences for the organism you are making a
       model for. This step uses both the output from step 1a and from 2b.
   3b. Constructs a model based on the fit to the HMMs and the chosen
       parameters.

   These steps are specific to the organism for which you are
   reconstructing the model.

   In principle the function looks at which output that is already available
   and runs only the parts that are required for step 3. This means
   that (see the definition of the parameters for details):
   -1a is only performed if there are no KEGG model files in the
   RAVEN\external\kegg directory
   -1b is only performed if not all required HMMs OR aligned FASTA files
   OR multi-FASTA files exist in the defined dataDir. This means that this
   step is skipped if the HMMs are downloaded from BioMet Toolbox instead
   (see above). If not all files exist it will try to find
   the KEGG database files in dataDir.
   -2a is only performed if not all required HMMs OR aligned FASTA files
   files exist in the defined dataDir. This means that this step is skipped
   if the HMMs are downloaded from BioMet Toolbox instead (see above).
   -2b is only performed if not all required HMMs exist in the defined
   dataDir. This means that this step is skipped if the FASTA files or
   HMMs are downloaded from BioMet Toolbox instead (see above).
   -3a is performed for the required HMMs for which no corresponding .out
   file exists in outDir. This is just a way to enable the function to be
   run in parallel or to resume if interrupted.
   -3b is always performed.

   Usage: model=getKEGGModelForOrganism(organismID,fastaFile,dataDir,outDir,...
    keepUndefinedStoich,keepIncomplete,keepGeneral,cutOff,minScoreRatioG,...
    minScoreRatioKO,maxPhylDist,nSequences,seqIdentity)

   Eduard Kerkhoven, 2018-05-18</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="getModelFromKEGG.html" class="code" title="function [model,KOModel]=getModelFromKEGG(keggPath,keepUndefinedStoich,keepIncomplete,keepGeneral)">getModelFromKEGG</a>	getModelFromKEGG</li><li><a href="getPhylDist.html" class="code" title="function phylDistStruct=getPhylDist(keggPath,onlyInKingdom)">getPhylDist</a>	getPhylDist</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function files=listFiles(directory)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function model=getKEGGModelForOrganism(organismID,fastaFile,dataDir,outDir,</a><span class="keyword">...</span>
0002     keepUndefinedStoich,keepIncomplete,keepGeneral,cutOff,minScoreRatioG,<span class="keyword">...</span>
0003     minScoreRatioKO,maxPhylDist,nSequences,seqIdentity)
0004 <span class="comment">% getKEGGModelForOrganism</span>
0005 <span class="comment">%   Reconstructs a genome-scale metabolic model based on protein homology to the</span>
0006 <span class="comment">%   orthologies in KEGG</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%   organismID          three or four letter abbreviation of the organism</span>
0009 <span class="comment">%                       (as used in KEGG). If not available, use a closely</span>
0010 <span class="comment">%                       related species. This is used for determing the</span>
0011 <span class="comment">%                       phylogenetic distance. Use 'eukaryotes' or</span>
0012 <span class="comment">%                       'prokaryotes' to get a model for the whole domain.</span>
0013 <span class="comment">%                       Only applicable if fastaFile is empty, i.e. no</span>
0014 <span class="comment">%                       homology search should be performed</span>
0015 <span class="comment">%   fastaFile           a FASTA file that contains the protein sequences of</span>
0016 <span class="comment">%                       the organism for which to reconstruct a model (opt,</span>
0017 <span class="comment">%                       if no FASTA file is supplied then a model is</span>
0018 <span class="comment">%                       reconstructed based only on the organism</span>
0019 <span class="comment">%                       abbreviation. This option ignores all settings</span>
0020 <span class="comment">%                       except for keepUndefinedStoich, keepIncomplete and</span>
0021 <span class="comment">%                       keepGeneral)</span>
0022 <span class="comment">%   dataDir             directory for which to retrieve the input data.</span>
0023 <span class="comment">%                       Should contain a combination of these sub-folders:</span>
0024 <span class="comment">%                       -dataDir\keggdb</span>
0025 <span class="comment">%                           The KEGG database files used in 1a (see below)</span>
0026 <span class="comment">%                       -dataDir\fasta</span>
0027 <span class="comment">%                           The multi-FASTA files generated in 1b (see</span>
0028 <span class="comment">%                           below)</span>
0029 <span class="comment">%                       -dataDir\aligned</span>
0030 <span class="comment">%                           The aligned FASTA files as generated in 2a (see</span>
0031 <span class="comment">%                           below)</span>
0032 <span class="comment">%                       -dataDir\hmms</span>
0033 <span class="comment">%                           The hidden Markov models as generated in 2b or</span>
0034 <span class="comment">%                           downloaded from BioMet Toolbox (see below)</span>
0035 <span class="comment">%                       The final directory in dataDir should be styled as</span>
0036 <span class="comment">%                       proXXX_keggYY or eukXXX_keggYY, indicating whether</span>
0037 <span class="comment">%                       the HMMs were trained on pro- or eukaryotic</span>
0038 <span class="comment">%                       sequences, using a sequence similarity threshold of</span>
0039 <span class="comment">%                       XXX %, fitting the KEGG version YY. E.g.</span>
0040 <span class="comment">%                       euk100_kegg82. (opt, see note about fastaFile. Note</span>
0041 <span class="comment">%                       that in order to rebuild the KEGG model from a</span>
0042 <span class="comment">%                       database dump, as opposed to using the version</span>
0043 <span class="comment">%                       supplied with RAVEN, you would still need to supply</span>
0044 <span class="comment">%                       this)</span>
0045 <span class="comment">%   outDir              directory to save the results from the quering of</span>
0046 <span class="comment">%                       the hidden Markov models. The output is specific</span>
0047 <span class="comment">%                       for the input sequences and the settings used. It</span>
0048 <span class="comment">%                       is stored in this manner so that the function can</span>
0049 <span class="comment">%                       continue if interrupted or if it should run in</span>
0050 <span class="comment">%                       parallel. Be careful not to leave output files from</span>
0051 <span class="comment">%                       different organisms or runs with different settings</span>
0052 <span class="comment">%                       in the same folder. They will not be overwritten</span>
0053 <span class="comment">%                       (opt, default is a temporary dir where all *.out</span>
0054 <span class="comment">%                       files are deleted before and after doing the</span>
0055 <span class="comment">%                       reconstruction)</span>
0056 <span class="comment">%   keepUndefinedStoich    include reactions in the form n A &lt;=&gt; n+1 A. These</span>
0057 <span class="comment">%                       will be dealt with as two separate metabolites</span>
0058 <span class="comment">%                       (opt, default true)</span>
0059 <span class="comment">%   keepIncomplete      include reactions which have been labelled as</span>
0060 <span class="comment">%                       &quot;incomplete&quot;, &quot;erroneous&quot; or &quot;unclear&quot; (opt,</span>
0061 <span class="comment">%                       default true)</span>
0062 <span class="comment">%   keepGeneral         include reactions which have been labelled as</span>
0063 <span class="comment">%                       &quot;general reaction&quot;. These are reactions on the form</span>
0064 <span class="comment">%                       &quot;an aldehyde &lt;=&gt; an alcohol&quot;, and are therefore</span>
0065 <span class="comment">%                       unsuited for modelling purposes. Note that not all</span>
0066 <span class="comment">%                       reactions have this type of annotation, and the</span>
0067 <span class="comment">%                       script will therefore not be able to remove all</span>
0068 <span class="comment">%                       such reactions (opt, default false)</span>
0069 <span class="comment">%   cutOff              significance score from HMMer needed to assign</span>
0070 <span class="comment">%                       genes to a KO (opt, default 10^-50)</span>
0071 <span class="comment">%   minScoreRatioG      a gene is only assigned to KOs for which the score</span>
0072 <span class="comment">%                       is &gt;=log(score)/log(best score) for that gene. This</span>
0073 <span class="comment">%                       is to prevent thata gene which clearly belongs to</span>
0074 <span class="comment">%                       one KO is assigned also to KOs with much lower</span>
0075 <span class="comment">%                       scores (opt, default 0.8 (lower is less strict))</span>
0076 <span class="comment">%   minScoreRatioKO     ignore genes in a KO if their score is</span>
0077 <span class="comment">%                       &lt;log(score)/log(best score in KO). This is to</span>
0078 <span class="comment">%                       &quot;prune&quot; KOs which havemany genes and where some are</span>
0079 <span class="comment">%                       clearly a better fit (opt, default 0.3 (lower is</span>
0080 <span class="comment">%                       less strict))</span>
0081 <span class="comment">%   maxPhylDist         -1: only use sequences from the same domain</span>
0082 <span class="comment">%                       (Prokaryota, Eukaryota)</span>
0083 <span class="comment">%                       other (positive) value: only use sequences for</span>
0084 <span class="comment">%                       organisms where the phylogenetic distance is at the</span>
0085 <span class="comment">%                       most this large (as calculated in getPhylDist)</span>
0086 <span class="comment">%                       (opt, default Inf, which means that all sequences</span>
0087 <span class="comment">%                       will be used)</span>
0088 <span class="comment">%   nSequences          for each KO, use up to this many sequences from the</span>
0089 <span class="comment">%                       most closely related species. This is mainly to</span>
0090 <span class="comment">%                       speed up the alignment process for KOs with very</span>
0091 <span class="comment">%                       many genes. This subsampling is performed before</span>
0092 <span class="comment">%                       running CD-HIT (opt, default inf)</span>
0093 <span class="comment">%   seqIdentity         sequence identity threshold in CD-HIT, referred as</span>
0094 <span class="comment">%                       &quot;global sequence identity&quot; in CD-HIT User's Guide.</span>
0095 <span class="comment">%                       The only possible options are 1 (100 %), 0.9 (90 %)</span>
0096 <span class="comment">%                       and 0.5 (50 %). If other values are provided,</span>
0097 <span class="comment">%                       CD-HIT is skipped (opt, default -1, i.e. CD-HIT is</span>
0098 <span class="comment">%                       skipped)</span>
0099 <span class="comment">%</span>
0100 <span class="comment">%   model               the reconstructed model</span>
0101 <span class="comment">%</span>
0102 <span class="comment">%   PLEASE READ THIS: The input to this function can be confusing, because</span>
0103 <span class="comment">%   it is intended to be run in parallel on a cluster or in multiple</span>
0104 <span class="comment">%   sessions. It therefore saves a lot of intermediate results to storage.</span>
0105 <span class="comment">%   This also serves the purpose of not having to do redundant</span>
0106 <span class="comment">%   calculations. This, however, comes with the disadvantage of somewhat</span>
0107 <span class="comment">%   trickier handling. This is what this function does:</span>
0108 <span class="comment">%</span>
0109 <span class="comment">%   1a. Loads files from a local KEGG FTP dump and constructs a general</span>
0110 <span class="comment">%       RAVEN model representing the metabolic network. KEGG FTP access</span>
0111 <span class="comment">%       requires a &lt;a href=&quot;matlab:</span>
0112 <span class="comment">%       web('http://www.bioinformatics.jp/en/keggftp.html')&quot;&gt;license&lt;/a&gt;.</span>
0113 <span class="comment">%   1b. Generates FASTA files from the KEGG FTP dump (see 1a). One</span>
0114 <span class="comment">%       multi-FASTA file for each KO in KEGG is generated. Make sure you</span>
0115 <span class="comment">%       actually need these first, as the parsing is time-consuming (see</span>
0116 <span class="comment">%       below).</span>
0117 <span class="comment">%</span>
0118 <span class="comment">%   These steps only have to be re-done every time KEGG updates their</span>
0119 <span class="comment">%   database (or rather when the updates are large enough to warrant</span>
0120 <span class="comment">%   rerunning this part). Many user would probably never use this feature.</span>
0121 <span class="comment">%</span>
0122 <span class="comment">%   2a. Does alignment of the multi-FASTA files for future use. This uses</span>
0123 <span class="comment">%       the settings &quot;useEvDist&quot; and &quot;nSequences&quot; to control which</span>
0124 <span class="comment">%       sequences should be used for constructing Hidden Markov models</span>
0125 <span class="comment">%       (HMMs), and later for matching your sequences to.</span>
0126 <span class="comment">%   2b. Trains hidden Markov models using HMMer for each of the aligned</span>
0127 <span class="comment">%       FASTA files.</span>
0128 <span class="comment">%</span>
0129 <span class="comment">%   The most common alternatives here would be to use sequences from only</span>
0130 <span class="comment">%   eukaryotes, only prokaryotes or all sequences in KEGG. As explained in</span>
0131 <span class="comment">%   the README.md file, various sets of pre-trained hidden Markov models are</span>
0132 <span class="comment">%   available at &lt;a href=&quot;matlab:</span>
0133 <span class="comment">%   web('http://biomet-toolbox.chalmers.se/index.php?page=downtools-raven')&quot;&gt;BioMet</span>
0134 <span class="comment">%   Toolbox&lt;/a&gt;. This is normally the most convenient way, but if you would</span>
0135 <span class="comment">%   like to use, for example, only fungal sequences for training the HMMs</span>
0136 <span class="comment">%   then you need to run this part.</span>
0137 <span class="comment">%</span>
0138 <span class="comment">%   3a. Queries the HMMs with sequences for the organism you are making a</span>
0139 <span class="comment">%       model for. This step uses both the output from step 1a and from 2b.</span>
0140 <span class="comment">%   3b. Constructs a model based on the fit to the HMMs and the chosen</span>
0141 <span class="comment">%       parameters.</span>
0142 <span class="comment">%</span>
0143 <span class="comment">%   These steps are specific to the organism for which you are</span>
0144 <span class="comment">%   reconstructing the model.</span>
0145 <span class="comment">%</span>
0146 <span class="comment">%   In principle the function looks at which output that is already available</span>
0147 <span class="comment">%   and runs only the parts that are required for step 3. This means</span>
0148 <span class="comment">%   that (see the definition of the parameters for details):</span>
0149 <span class="comment">%   -1a is only performed if there are no KEGG model files in the</span>
0150 <span class="comment">%   RAVEN\external\kegg directory</span>
0151 <span class="comment">%   -1b is only performed if not all required HMMs OR aligned FASTA files</span>
0152 <span class="comment">%   OR multi-FASTA files exist in the defined dataDir. This means that this</span>
0153 <span class="comment">%   step is skipped if the HMMs are downloaded from BioMet Toolbox instead</span>
0154 <span class="comment">%   (see above). If not all files exist it will try to find</span>
0155 <span class="comment">%   the KEGG database files in dataDir.</span>
0156 <span class="comment">%   -2a is only performed if not all required HMMs OR aligned FASTA files</span>
0157 <span class="comment">%   files exist in the defined dataDir. This means that this step is skipped</span>
0158 <span class="comment">%   if the HMMs are downloaded from BioMet Toolbox instead (see above).</span>
0159 <span class="comment">%   -2b is only performed if not all required HMMs exist in the defined</span>
0160 <span class="comment">%   dataDir. This means that this step is skipped if the FASTA files or</span>
0161 <span class="comment">%   HMMs are downloaded from BioMet Toolbox instead (see above).</span>
0162 <span class="comment">%   -3a is performed for the required HMMs for which no corresponding .out</span>
0163 <span class="comment">%   file exists in outDir. This is just a way to enable the function to be</span>
0164 <span class="comment">%   run in parallel or to resume if interrupted.</span>
0165 <span class="comment">%   -3b is always performed.</span>
0166 <span class="comment">%</span>
0167 <span class="comment">%   Usage: model=getKEGGModelForOrganism(organismID,fastaFile,dataDir,outDir,...</span>
0168 <span class="comment">%    keepUndefinedStoich,keepIncomplete,keepGeneral,cutOff,minScoreRatioG,...</span>
0169 <span class="comment">%    minScoreRatioKO,maxPhylDist,nSequences,seqIdentity)</span>
0170 <span class="comment">%</span>
0171 <span class="comment">%   Eduard Kerkhoven, 2018-05-18</span>
0172 <span class="comment">%</span>
0173 
0174 <span class="keyword">if</span> nargin&lt;2
0175     fastaFile=[];
0176 <span class="keyword">end</span>
0177 <span class="keyword">if</span> nargin&lt;3
0178     dataDir=[];
0179 <span class="keyword">end</span>
0180 <span class="keyword">if</span> nargin&lt;4
0181     outDir=[];
0182 <span class="keyword">end</span>
0183 <span class="keyword">if</span> isempty(outDir)
0184     outDir=tempdir;
0185     <span class="comment">%Delete all *.out files if any exist</span>
0186     delete(fullfile(outDir,<span class="string">'*.out'</span>));
0187 <span class="keyword">end</span>
0188 <span class="keyword">if</span> nargin&lt;5
0189     keepUndefinedStoich=true;
0190 <span class="keyword">end</span>
0191 <span class="keyword">if</span> nargin&lt;6
0192     keepIncomplete=true;
0193 <span class="keyword">end</span>
0194 <span class="keyword">if</span> nargin&lt;7
0195     keepGeneral=false;
0196 <span class="keyword">end</span>
0197 <span class="keyword">if</span> nargin&lt;8
0198     cutOff=10^-50;
0199 <span class="keyword">end</span>
0200 <span class="keyword">if</span> nargin&lt;9
0201     minScoreRatioG=0.8;
0202 <span class="keyword">end</span>
0203 <span class="keyword">if</span> nargin&lt;10
0204     minScoreRatioKO=0.3;
0205 <span class="keyword">end</span>
0206 <span class="keyword">if</span> nargin&lt;11
0207     maxPhylDist=inf;
0208     <span class="comment">%Include all sequences for each reaction</span>
0209 <span class="keyword">end</span>
0210 <span class="keyword">if</span> nargin&lt;12
0211     nSequences=inf;
0212     <span class="comment">%Include all sequences for each reaction</span>
0213 <span class="keyword">end</span>
0214 <span class="keyword">if</span> nargin&lt;13
0215     seqIdentity=-1;
0216     <span class="comment">%CD-HIT is not used in the pipeline</span>
0217 <span class="keyword">end</span>
0218 
0219 <span class="comment">%Check that FASTA file exists</span>
0220 <span class="keyword">if</span> ~isempty(fastaFile)
0221     <span class="keyword">if</span> ~(exist(fastaFile,<span class="string">'file'</span>)==2)
0222         error(<span class="string">'FASTA file %s cannot be found'</span>,string(fastaFile));
0223     <span class="keyword">end</span>
0224 <span class="keyword">end</span>
0225 <span class="comment">%Run the external binaries multi-threaded to use all logical cores assigned</span>
0226 <span class="comment">%to MATLAB</span>
0227 cores = evalc(<span class="string">'feature(''numcores'')'</span>);
0228 cores = strsplit(cores, <span class="string">'MATLAB was assigned: '</span>);
0229 cores = regexp(cores{2},<span class="string">'^\d*'</span>,<span class="string">'match'</span>);
0230 cores = cores{1};
0231 
0232 <span class="comment">%Checking if dataDir is consistent. It must point to pre-trained HMMs set,</span>
0233 <span class="comment">%compatible with the the current RAVEN version. The user may have the</span>
0234 <span class="comment">%required zip file already in working directory or have it extracted. If</span>
0235 <span class="comment">%the zip file and directory is not here, it is downloaded from BioMet</span>
0236 <span class="comment">%ToolBox 2.0 server.</span>
0237 <span class="keyword">if</span> ~isempty(dataDir)
0238     hmmOptions={<span class="string">'euk100_kegg82'</span>; <span class="keyword">...</span>
0239         <span class="string">'euk90_kegg82'</span>; <span class="keyword">...</span>
0240         <span class="string">'euk50_kegg82'</span>; <span class="keyword">...</span>
0241         <span class="string">'prok100_kegg82'</span>; <span class="keyword">...</span>
0242         <span class="string">'prok90_kegg82'</span>; <span class="keyword">...</span>
0243         <span class="string">'prok50_kegg82'</span>};
0244     <span class="keyword">if</span> all(cellfun(@isempty,regexp(dataDir,strcat(hmmOptions,<span class="string">'$'</span>)))) <span class="comment">% Check if dataDir ends with any of the hmmOptions</span>
0245         EM=<span class="string">'Pre-trained HMMs set is not recognised. It should match any of the following sets (which are available to download):'</span>;
0246         disp(EM);
0247         disp(hmmOptions);
0248         <span class="keyword">return</span>;
0249     <span class="keyword">end</span>
0250     <span class="keyword">if</span> exist(dataDir,<span class="string">'dir'</span>)
0251         fprintf(<span class="string">'Provided dataDir is in correct format for this RAVEN version in order to use pre-trained HMMs...\n'</span>)
0252     <span class="keyword">elseif</span> ~exist(dataDir,<span class="string">'dir'</span>) &amp;&amp; exist([dataDir,<span class="string">'.zip'</span>],<span class="string">'file'</span>)
0253         fprintf(<span class="string">'Extracting HMMs archive file...\n'</span>);
0254         unzip([dataDir,<span class="string">'.zip'</span>]);
0255     <span class="keyword">else</span>
0256         fprintf(<span class="string">'Downloading HMMs archive file...\n'</span>);
0257         websave([dataDir,<span class="string">'.zip'</span>],[<span class="string">'http://biomet-toolbox.chalmers.se/tools/downloadable/files/'</span>,dataDir,<span class="string">'.zip'</span>]);
0258         fprintf(<span class="string">'Extracting HMMs archive file...\n'</span>);
0259         unzip([dataDir,<span class="string">'.zip'</span>]);
0260     <span class="keyword">end</span>
0261 <span class="keyword">end</span>
0262 
0263 <span class="comment">%Check if the fasta-file contains '/' or'\'. If not then it's probably just</span>
0264 <span class="comment">%a file name. It is then merged with the current folder</span>
0265 <span class="keyword">if</span> any(fastaFile)
0266     <span class="keyword">if</span> ~any(strfind(fastaFile,<span class="string">'\'</span>)) &amp;&amp; ~any(strfind(fastaFile,<span class="string">'/'</span>))
0267         fastaFile=fullfile(pwd,fastaFile);
0268     <span class="keyword">end</span>
0269     <span class="comment">%Create the required sub-folders in dataDir if they dont exist</span>
0270     <span class="keyword">if</span> ~exist(fullfile(dataDir,<span class="string">'keggdb'</span>),<span class="string">'dir'</span>)
0271         mkdir(dataDir,<span class="string">'keggdb'</span>);
0272     <span class="keyword">end</span>
0273     <span class="keyword">if</span> ~exist(fullfile(dataDir,<span class="string">'fasta'</span>),<span class="string">'dir'</span>)
0274         mkdir(dataDir,<span class="string">'fasta'</span>);
0275     <span class="keyword">end</span>
0276     <span class="keyword">if</span> ~exist(fullfile(dataDir,<span class="string">'aligned'</span>),<span class="string">'dir'</span>)
0277         mkdir(dataDir,<span class="string">'aligned'</span>);
0278     <span class="keyword">end</span>
0279     <span class="keyword">if</span> ~exist(fullfile(dataDir,<span class="string">'hmms'</span>),<span class="string">'dir'</span>)
0280         mkdir(dataDir,<span class="string">'hmms'</span>);
0281     <span class="keyword">end</span>
0282     <span class="keyword">if</span> ~exist(outDir,<span class="string">'dir'</span>)
0283         mkdir(outDir);
0284     <span class="keyword">end</span>
0285 <span class="keyword">end</span>
0286 
0287 <span class="comment">%First generate the full KEGG model. The dataDir mustn't be supplied as</span>
0288 <span class="comment">%there is also an internal RAVEN version available</span>
0289 <span class="keyword">if</span> any(dataDir)
0290     [model, KOModel]=<a href="getModelFromKEGG.html" class="code" title="function [model,KOModel]=getModelFromKEGG(keggPath,keepUndefinedStoich,keepIncomplete,keepGeneral)">getModelFromKEGG</a>(fullfile(dataDir,<span class="string">'keggdb'</span>),keepUndefinedStoich,keepIncomplete,keepGeneral);
0291 <span class="keyword">else</span>
0292     [model, KOModel]=<a href="getModelFromKEGG.html" class="code" title="function [model,KOModel]=getModelFromKEGG(keggPath,keepUndefinedStoich,keepIncomplete,keepGeneral)">getModelFromKEGG</a>([],keepUndefinedStoich,keepIncomplete,keepGeneral);
0293 <span class="keyword">end</span>
0294 fprintf(<span class="string">'Completed generation of KEGG model\n'</span>);
0295 model.id=organismID;
0296 model.c=zeros(numel(model.rxns),1);
0297 
0298 <span class="comment">%If no FASTA file is supplied, then just remove all genes which are not for</span>
0299 <span class="comment">%the given organism ID</span>
0300 <span class="keyword">if</span> isempty(fastaFile)
0301     <span class="keyword">if</span> ismember(organismID,{<span class="string">'eukaryotes'</span>,<span class="string">'prokaryotes'</span>})
0302         phylDists=<a href="getPhylDist.html" class="code" title="function phylDistStruct=getPhylDist(keggPath,onlyInKingdom)">getPhylDist</a>(fullfile(dataDir,<span class="string">'keggdb'</span>),maxPhylDist==-1);
0303         <span class="keyword">if</span> strcmp(organismID,<span class="string">'eukaryotes'</span>)
0304             proxyid=<span class="string">'hsa'</span>;
0305             <span class="comment">%Use H. sapiens here</span>
0306         <span class="keyword">else</span>
0307             proxyid=<span class="string">'eco'</span>;
0308             <span class="comment">%Use E. coli here</span>
0309         <span class="keyword">end</span>
0310         [~, phylDistId]=ismember(proxyid,phylDists.ids);
0311         idsToKeep=phylDists.ids(~isinf(phylDists.distMat(phylDistId,:)));
0312         taxIDs=cellfun(@(x) x{1},cellfun(@(x) strsplit(x,<span class="string">':'</span>),model.genes,<span class="string">'UniformOutput'</span>,false),<span class="string">'UniformOutput'</span>,false);
0313         I=ismember(upper(taxIDs),upper(idsToKeep));
0314     <span class="keyword">else</span>
0315         <span class="comment">%KEGG organism IDs may have three or four letters</span>
0316         organismID=strcat(organismID,<span class="string">':'</span>);
0317         <span class="comment">%Add colon for accurate matching</span>
0318         <span class="keyword">if</span> length(organismID)==4
0319             I=cellfun(@(x) strcmpi(x(1:4),organismID),model.genes);
0320         <span class="keyword">elseif</span> length(organismID)==5
0321             I=cellfun(@(x) strcmpi(x(1:5),organismID),model.genes);
0322         <span class="keyword">end</span>
0323     <span class="keyword">end</span>
0324     <span class="comment">%Remove those genes</span>
0325     model.genes=model.genes(I);
0326     model.rxnGeneMat=model.rxnGeneMat(:,I);
0327 <span class="keyword">end</span>
0328 
0329 <span class="comment">%First remove all reactions without genes</span>
0330 hasGenes=any(model.rxnGeneMat,2);
0331 model=removeReactions(model,~hasGenes,true);
0332 
0333 <span class="comment">%Clean gene names</span>
0334 <span class="keyword">for</span> i=1:numel(model.genes)
0335     <span class="comment">%First get rid of the prefix organism id</span>
0336     model.genes{i}=model.genes{i}(strfind(model.genes{i},<span class="string">':'</span>)+1:end);
0337     <span class="comment">%Find and remove the description in parentheses if any</span>
0338     s=strfind(model.genes{i},<span class="string">'('</span>);
0339     <span class="keyword">if</span> any(s)
0340         model.genes{i}=model.genes{i}(1:s-1);
0341     <span class="keyword">end</span>
0342 <span class="keyword">end</span>
0343 
0344 <span class="comment">%If no FASTA file is supplied, then we're done here</span>
0345 <span class="keyword">if</span> isempty(fastaFile)
0346     <span class="comment">%Create grRules</span>
0347     model.grRules=cell(numel(model.rxns),1);
0348     model.grRules(:)={<span class="string">''</span>};
0349     <span class="comment">%Add the gene associations as 'or'</span>
0350     <span class="keyword">for</span> i=1:numel(model.rxns)
0351         <span class="comment">%Find the involved genes</span>
0352         I=find(model.rxnGeneMat(i,:));
0353         model.grRules{i}=[<span class="string">'('</span> model.genes{I(1)}];
0354         <span class="keyword">for</span> j=2:numel(I)
0355             model.grRules{i}=[model.grRules{i} <span class="string">' or '</span> model.genes{I(j)}];
0356         <span class="keyword">end</span>
0357         model.grRules{i}=[model.grRules{i} <span class="string">')'</span>];
0358     <span class="keyword">end</span>
0359     <span class="comment">%Add geneMiriams, assuming that it follows the syntax</span>
0360     <span class="comment">%kegg.genes/organismID:geneName</span>
0361     model.geneMiriams=<span class="string">''</span>;
0362     <span class="keyword">for</span> i=1:numel(model.genes)
0363         model.geneMiriams{i,1}.name{1,1}=<span class="string">'kegg.genes'</span>;
0364         model.geneMiriams{i,1}.value{1,1}=strcat(lower(organismID),model.genes{i,1});
0365     <span class="keyword">end</span>
0366     <span class="keyword">return</span>;
0367 <span class="keyword">end</span>
0368 
0369 <span class="comment">%Trim the genes so that they only contain information that can be matched</span>
0370 <span class="comment">%to the KEGG file of protein sequences (remove all information after first</span>
0371 <span class="comment">%parenthesis) NOTE: For some reason the organism abbreviation should be in</span>
0372 <span class="comment">%lower case in this database. Fix this here</span>
0373 <span class="keyword">for</span> i=1:numel(KOModel.genes)
0374     parIndex=strfind(KOModel.genes{i},<span class="string">'('</span>);
0375     <span class="keyword">if</span> any(parIndex)
0376         KOModel.genes{i}=KOModel.genes{i}(1:parIndex-1);
0377     <span class="keyword">end</span>
0378     colIndex=strfind(KOModel.genes{i},<span class="string">':'</span>);
0379     KOModel.genes{i}=[lower(KOModel.genes{i}(1:colIndex-1)) KOModel.genes{i}(colIndex:end)];
0380 <span class="keyword">end</span>
0381 
0382 <span class="comment">%Create a phylogenetic distance structure</span>
0383 phylDistStruct=<a href="getPhylDist.html" class="code" title="function phylDistStruct=getPhylDist(keggPath,onlyInKingdom)">getPhylDist</a>(fullfile(dataDir,<span class="string">'keggdb'</span>),maxPhylDist==-1);
0384 [~, phylDistId]=ismember(model.id,phylDistStruct.ids);
0385 fprintf(<span class="string">'Completed creation of phylogenetic distance matrix\n'</span>);
0386 
0387 <span class="comment">%Calculate the real maximal distance now. An abitary large number of 1000</span>
0388 <span class="comment">%is used for the &quot;all in kingdom&quot; or &quot;all sequences&quot; options. This is a bit</span>
0389 <span class="comment">%inconvenient way to do it, but it's to make it fit with some older code</span>
0390 <span class="keyword">if</span> isinf(maxPhylDist) || maxPhylDist==-1
0391     maxPhylDist=1000;
0392 <span class="keyword">end</span>
0393 
0394 <span class="comment">%Get the KO ids for which files have been generated. Maybe not the neatest</span>
0395 <span class="comment">%way..</span>
0396 fastaFiles=<a href="#_sub1" class="code" title="subfunction files=listFiles(directory)">listFiles</a>(fullfile(dataDir,<span class="string">'fasta'</span>,<span class="string">'*.fa'</span>));
0397 alignedFiles=<a href="#_sub1" class="code" title="subfunction files=listFiles(directory)">listFiles</a>(fullfile(dataDir,<span class="string">'aligned'</span>,<span class="string">'*.fa'</span>));
0398 alignedWorking=<a href="#_sub1" class="code" title="subfunction files=listFiles(directory)">listFiles</a>(fullfile(dataDir,<span class="string">'aligned'</span>,<span class="string">'*.faw'</span>));
0399 hmmFiles=<a href="#_sub1" class="code" title="subfunction files=listFiles(directory)">listFiles</a>(fullfile(dataDir,<span class="string">'hmms'</span>,<span class="string">'*.hmm'</span>));
0400 outFiles=<a href="#_sub1" class="code" title="subfunction files=listFiles(directory)">listFiles</a>(fullfile(outDir,<span class="string">'*.out'</span>));
0401 
0402 <span class="comment">%Check if multi-FASTA files should be generated. This should only be</span>
0403 <span class="comment">%performed if there are IDs in the KOModel structure that haven't been</span>
0404 <span class="comment">%parsed yet</span>
0405 missingFASTA=setdiff(KOModel.rxns,[fastaFiles;alignedFiles;hmmFiles;outFiles]);
0406 
0407 <span class="keyword">if</span> ~isempty(missingFASTA)
0408     <span class="keyword">if</span> ~exist(fullfile(dataDir,<span class="string">'keggdb'</span>,<span class="string">'genes.pep'</span>),<span class="string">'file'</span>)
0409         EM=fprintf([<span class="string">'The file ''genes.pep'' cannot be located at '</span> strrep(dataDir,<span class="string">'\'</span>,<span class="string">'/'</span>) <span class="string">'/ and should be downloaded from the KEGG FTP.\n'</span>]);
0410         dispEM(EM);
0411     <span class="keyword">end</span>
0412     <span class="comment">%Only construct models for KOs which don't have files already</span>
0413     fastaModel=removeReactions(KOModel,setdiff(KOModel.rxns,missingFASTA),true,true);
0414     <span class="comment">%Permute the order of the KOs in the model so that constructMultiFasta</span>
0415     <span class="comment">%can be run on several processors at once</span>
0416     fastaModel=permuteModel(fastaModel,randperm(RandStream.create(<span class="string">'mrg32k3a'</span>,<span class="string">'Seed'</span>,cputime()),numel(fastaModel.rxns)),<span class="string">'rxns'</span>);
0417     constructMultiFasta(fastaModel,fullfile(dataDir,<span class="string">'keggdb'</span>,<span class="string">'genes.pep'</span>),fullfile(dataDir,<span class="string">'fasta'</span>));
0418 <span class="keyword">end</span>
0419 fprintf(<span class="string">'Completed generation of multi-FASTA files\n'</span>);
0420 
0421 <span class="comment">%Get the directory for RAVEN Toolbox. This is to get the path to the third</span>
0422 <span class="comment">%party software used</span>
0423 [ST, I]=dbstack(<span class="string">'-completenames'</span>);
0424 ravenPath=fileparts(fileparts(fileparts(ST(I).file)));
0425 
0426 <span class="keyword">if</span> isunix
0427     <span class="keyword">if</span> ismac
0428         binEnd=<span class="string">'.mac'</span>;
0429     <span class="keyword">else</span>
0430         binEnd=<span class="string">''</span>;
0431     <span class="keyword">end</span>
0432 <span class="keyword">elseif</span> ispc
0433     binEnd=<span class="string">''</span>;
0434 <span class="keyword">else</span>
0435     EM=<span class="string">'Unknown OS, exiting.'</span>;
0436     disp(EM);
0437     <span class="keyword">return</span>
0438 <span class="keyword">end</span>
0439 
0440 <span class="comment">%Check if alignment of FASTA files should be performed</span>
0441 missingAligned=setdiff(KOModel.rxns,[alignedFiles;hmmFiles;alignedWorking;outFiles]);
0442 <span class="keyword">if</span> ~isempty(missingAligned)
0443     missingAligned=missingAligned(randperm(RandStream.create(<span class="string">'mrg32k3a'</span>,<span class="string">'Seed'</span>,cputime()),numel(missingAligned)));
0444     <span class="comment">%Align all sequences using MAFFT</span>
0445     <span class="keyword">for</span> i=1:numel(missingAligned)
0446         <span class="comment">%This is checked here because it could be that it is created by a</span>
0447         <span class="comment">%parallel process. The faw-files are saved as temporary files to</span>
0448         <span class="comment">%kept track of which files are being worked on</span>
0449         <span class="keyword">if</span> ~exist(fullfile(dataDir,<span class="string">'aligned'</span>,[missingAligned{i} <span class="string">'.faw'</span>]),<span class="string">'file'</span>) &amp;&amp; ~exist(fullfile(dataDir,<span class="string">'aligned'</span>,[missingAligned{i} <span class="string">'.fa'</span>]),<span class="string">'file'</span>)
0450             <span class="comment">%Check that the multi-FASTA file exists. It should do so since</span>
0451             <span class="comment">%we are saving empty files as well. Print a warning and</span>
0452             <span class="comment">%continue if not</span>
0453             <span class="keyword">if</span> ~exist(fullfile(dataDir,<span class="string">'fasta'</span>,[missingAligned{i} <span class="string">'.fa'</span>]),<span class="string">'file'</span>)
0454                 EM=[<span class="string">'WARNING: The multi-FASTA file for '</span> missingAligned{i} <span class="string">' does not exist'</span>];
0455                 dispEM(EM,false);
0456                 <span class="keyword">continue</span>;
0457             <span class="keyword">end</span>
0458             
0459             <span class="comment">%If the multi-FASTA file is empty then save an empty aligned</span>
0460             <span class="comment">%file and continue</span>
0461             s=dir(fullfile(dataDir,<span class="string">'fasta'</span>,[missingAligned{i} <span class="string">'.fa'</span>]));
0462             <span class="keyword">if</span> s.bytes&lt;=0
0463                 fid=fopen(fullfile(dataDir,<span class="string">'aligned'</span>,[missingAligned{i} <span class="string">'.fa'</span>]),<span class="string">'w'</span>);
0464                 fclose(fid);
0465                 <span class="keyword">continue</span>;
0466             <span class="keyword">end</span>
0467             
0468             <span class="comment">%Create an empty file to prevent other threads to start to work</span>
0469             <span class="comment">%on the same alignment</span>
0470             fid=fopen(fullfile(dataDir,<span class="string">'aligned'</span>,[missingAligned{i} <span class="string">'.faw'</span>]),<span class="string">'w'</span>);
0471             fclose(fid);
0472             
0473             <span class="comment">%First load the FASTA file, then select up to nSequences</span>
0474             <span class="comment">%sequences of the most closely related species, apply any</span>
0475             <span class="comment">%constraints from maxPhylDist, and save it as a temporary file,</span>
0476             <span class="comment">%and create the model from that</span>
0477             
0478             fastaStruct=fastaread(fullfile(dataDir,<span class="string">'fasta'</span>,[missingAligned{i} <span class="string">'.fa'</span>]));
0479             phylDist=inf(numel(fastaStruct),1);
0480             <span class="keyword">for</span> j=1:numel(fastaStruct)
0481                 <span class="comment">%Get the organism abbreviation</span>
0482                 index=strfind(fastaStruct(j).Header,<span class="string">':'</span>);
0483                 <span class="keyword">if</span> any(index)
0484                     abbrev=fastaStruct(j).Header(1:index(1)-1);
0485                     [~, index]=ismember(abbrev,phylDistStruct.ids);
0486                     <span class="keyword">if</span> any(index)
0487                         phylDist(j)=phylDistStruct.distMat(index(1),phylDistId);
0488                     <span class="keyword">end</span>
0489                 <span class="keyword">end</span>
0490             <span class="keyword">end</span>
0491             
0492             <span class="comment">%Inf means that it should not be included</span>
0493             phylDist(phylDist&gt;maxPhylDist)=[];
0494             
0495             <span class="comment">%Sort based on phylDist</span>
0496             [~, order]=sort(phylDist);
0497             
0498             <span class="comment">%Save the first nSequences hits to a temporary FASTA file</span>
0499             <span class="keyword">if</span> nSequences&lt;=numel(fastaStruct)
0500                 fastaStruct=fastaStruct(order(1:nSequences));
0501             <span class="keyword">else</span>
0502                 fastaStruct=fastaStruct(order);
0503             <span class="keyword">end</span>
0504             
0505             <span class="comment">%Do the alignment if there are more than one sequences,</span>
0506             <span class="comment">%otherwise just save the sequence (or an empty file)</span>
0507             <span class="keyword">if</span> numel(fastaStruct)&gt;1
0508                 <span class="keyword">if</span> (seqIdentity==1 || seqIdentity==0.9 || seqIdentity==0.5)
0509                     <span class="keyword">if</span> ~ispc
0510                         <span class="keyword">if</span> seqIdentity==1
0511                             cdhitInp100=tempname;
0512                             fastawrite(cdhitInp100,fastaStruct);
0513                             tmpFile=tempname;
0514                             [status, output]=unix([<span class="string">'&quot;'</span> fullfile(ravenPath,<span class="string">'software'</span>,<span class="string">'cd-hit-v4.6.6'</span>,[<span class="string">'cd-hit'</span> binEnd]) <span class="string">'&quot; -T &quot;'</span> cores <span class="string">'&quot; -i &quot;'</span> cdhitInp100 <span class="string">'&quot; -o &quot;'</span> tmpFile <span class="string">'&quot; -c 1.0 -s 0.8 -n 5 -M 2000'</span>]);
0515                             <span class="keyword">if</span> status~=0
0516                                 EM=[<span class="string">'Error when performing clustering of '</span> missingAligned{i} <span class="string">':\n'</span> output];
0517                                 dispEM(EM);
0518                             <span class="keyword">end</span>
0519                             <span class="comment">%Remove the old tempfile</span>
0520                             <span class="keyword">if</span> exist(cdhitInp100, <span class="string">'file'</span>)
0521                                 delete([cdhitInp100 <span class="string">'*'</span>]);
0522                             <span class="keyword">end</span>
0523                         <span class="keyword">elseif</span> seqIdentity==0.9
0524                             cdhitInp100=tempname;
0525                             fastawrite(cdhitInp100,fastaStruct);
0526                             cdhitInp90=tempname;
0527                             [status, output]=unix([<span class="string">'&quot;'</span> fullfile(ravenPath,<span class="string">'software'</span>,<span class="string">'cd-hit-v4.6.6'</span>,[<span class="string">'cd-hit'</span> binEnd]) <span class="string">'&quot; -T &quot;'</span> cores <span class="string">'&quot; -i &quot;'</span> cdhitInp100 <span class="string">'&quot; -o &quot;'</span> cdhitInp90 <span class="string">'&quot; -c 1.0 -s 0.8 -n 5 -M 2000'</span>]);
0528                             <span class="keyword">if</span> status~=0
0529                                 EM=[<span class="string">'Error when performing clustering of '</span> missingAligned{i} <span class="string">':\n'</span> output];
0530                                 dispEM(EM);
0531                             <span class="keyword">end</span>
0532                             <span class="comment">%Remove the old tempfile</span>
0533                             <span class="keyword">if</span> exist(cdhitInp100, <span class="string">'file'</span>)
0534                                 delete([cdhitInp100 <span class="string">'*'</span>]);
0535                             <span class="keyword">end</span>
0536                             tmpFile=tempname;
0537                             [status, output]=unix([<span class="string">'&quot;'</span> fullfile(ravenPath,<span class="string">'software'</span>,<span class="string">'cd-hit-v4.6.6'</span>,[<span class="string">'cd-hit'</span> binEnd]) <span class="string">'&quot; -T &quot;'</span> cores <span class="string">'&quot; -i &quot;'</span> cdhitInp90 <span class="string">'&quot; -o &quot;'</span> tmpFile <span class="string">'&quot; -c 0.9 -s 0.8 -n 5 -M 2000'</span>]);
0538                             <span class="keyword">if</span> status~=0
0539                                 EM=[<span class="string">'Error when performing clustering of '</span> missingAligned{i} <span class="string">':\n'</span> output];
0540                                 dispEM(EM);
0541                             <span class="keyword">end</span>
0542                             <span class="comment">%Remove the old tempfile</span>
0543                             <span class="keyword">if</span> exist(cdhitInp90, <span class="string">'file'</span>)
0544                                 delete([cdhitInp90 <span class="string">'*'</span>]);
0545                             <span class="keyword">end</span>
0546                         <span class="keyword">elseif</span> seqIdentity==0.5
0547                             cdhitInp100=tempname;
0548                             fastawrite(cdhitInp100,fastaStruct);
0549                             cdhitInp90=tempname;
0550                             [status, output]=unix([<span class="string">'&quot;'</span> fullfile(ravenPath,<span class="string">'software'</span>,<span class="string">'cd-hit-v4.6.6'</span>,[<span class="string">'cd-hit'</span> binEnd]) <span class="string">'&quot; -T &quot;'</span> cores <span class="string">'&quot; -i &quot;'</span> cdhitInp100 <span class="string">'&quot; -o &quot;'</span> cdhitInp90 <span class="string">'&quot; -c 1.0 -s 0.8 -n 5 -M 2000'</span>]);
0551                             <span class="keyword">if</span> status~=0
0552                                 EM=[<span class="string">'Error when performing clustering of '</span> missingAligned{i} <span class="string">':\n'</span> output];
0553                                 dispEM(EM);
0554                             <span class="keyword">end</span>
0555                             <span class="comment">%Remove the old tempfile</span>
0556                             <span class="keyword">if</span> exist(cdhitInp100, <span class="string">'file'</span>)
0557                                 delete([cdhitInp100 <span class="string">'*'</span>]);
0558                             <span class="keyword">end</span>
0559                             cdhitInp50=tempname;
0560                             [status, output]=unix([<span class="string">'&quot;'</span> fullfile(ravenPath,<span class="string">'software'</span>,<span class="string">'cd-hit-v4.6.6'</span>,[<span class="string">'cd-hit'</span> binEnd]) <span class="string">'&quot; -T &quot;'</span> cores <span class="string">'&quot; -i &quot;'</span> cdhitInp90 <span class="string">'&quot; -o &quot;'</span> cdhitInp50 <span class="string">'&quot; -c 0.9 -s 0.8 -n 5 -M 2000'</span>]);
0561                             <span class="keyword">if</span> status~=0
0562                                 EM=[<span class="string">'Error when performing clustering of '</span> missingAligned{i} <span class="string">':\n'</span> output];
0563                                 dispEM(EM);
0564                             <span class="keyword">end</span>
0565                             <span class="comment">%Remove the old tempfile</span>
0566                             <span class="keyword">if</span> exist(cdhitInp90, <span class="string">'file'</span>)
0567                                 delete([cdhitInp90 <span class="string">'*'</span>]);
0568                             <span class="keyword">end</span>
0569                             tmpFile=tempname;
0570                             [status, output]=unix([<span class="string">'&quot;'</span> fullfile(ravenPath,<span class="string">'software'</span>,<span class="string">'cd-hit-v4.6.6'</span>,[<span class="string">'cd-hit'</span> binEnd]) <span class="string">'&quot; -T &quot;'</span> cores <span class="string">'&quot; -i &quot;'</span> cdhitInp50 <span class="string">'&quot; -o &quot;'</span> tmpFile <span class="string">'&quot; -c 0.5 -s 0.8 -n 3 -M 2000'</span>]);
0571                             <span class="keyword">if</span> status~=0
0572                                 EM=[<span class="string">'Error when performing clustering of '</span> missingAligned{i} <span class="string">':\n'</span> output];
0573                                 dispEM(EM);
0574                             <span class="keyword">end</span>
0575                             <span class="comment">%Remove the old tempfile</span>
0576                             <span class="keyword">if</span> exist(cdhitInp50, <span class="string">'file'</span>)
0577                                 delete([cdhitInp50 <span class="string">'*'</span>]);
0578                             <span class="keyword">end</span>
0579                         <span class="keyword">end</span>
0580                     <span class="keyword">else</span>
0581                         <span class="comment">%CD-HIT is not available in Windows so we just</span>
0582                         <span class="comment">%export multifasta file into temporary file;</span>
0583                         tmpFile=tempname;
0584                         fastawrite(tmpFile,fastaStruct);
0585                     <span class="keyword">end</span>
0586                 <span class="keyword">else</span>
0587                     tmpFile=tempname;
0588                     fastawrite(tmpFile,fastaStruct);
0589                 <span class="keyword">end</span>
0590                 <span class="comment">%Do the alignment for this file</span>
0591                 <span class="keyword">if</span> ~ispc
0592                     [status, output]=system([<span class="string">'&quot;'</span> fullfile(ravenPath,<span class="string">'software'</span>,<span class="string">'mafft-7.305'</span>,[<span class="string">'mafft'</span> binEnd]) <span class="string">'&quot; --auto --thread &quot;'</span> cores <span class="string">'&quot; &quot;'</span> tmpFile <span class="string">'&quot; &gt; &quot;'</span> fullfile(dataDir,<span class="string">'aligned'</span>,[missingAligned{i} <span class="string">'.faw'</span>]) <span class="string">'&quot;'</span>]);
0593                 <span class="keyword">else</span>
0594                     [status, output]=system([<span class="string">'&quot;'</span> fullfile(ravenPath,<span class="string">'software'</span>,<span class="string">'mafft-7.305'</span>,<span class="string">'mafft.bat'</span>) <span class="string">'&quot; --auto --thread &quot;'</span> cores <span class="string">'&quot; &quot;'</span> tmpFile <span class="string">'&quot; &gt; &quot;'</span> fullfile(dataDir,<span class="string">'aligned'</span>,[missingAligned{i} <span class="string">'.faw'</span>]) <span class="string">'&quot;'</span>]);
0595                 <span class="keyword">end</span>
0596                 <span class="keyword">if</span> status~=0
0597                     EM=[<span class="string">'Error when performing alignment of '</span> missingAligned{i} <span class="string">':\n'</span> output];
0598                     dispEM(EM);
0599                 <span class="keyword">end</span>
0600                 <span class="comment">%Remove the old tempfile</span>
0601                 <span class="keyword">if</span> exist(tmpFile, <span class="string">'file'</span>)
0602                     delete([tmpFile <span class="string">'*'</span>]);
0603                 <span class="keyword">end</span>
0604             <span class="keyword">else</span>
0605                 <span class="comment">%If there is only one sequence then it's not possible to do</span>
0606                 <span class="comment">%a multiple alignment. Just print the sequence instead. An</span>
0607                 <span class="comment">%empty file was written previously so that doesn't have to</span>
0608                 <span class="comment">%be dealt with</span>
0609                 <span class="keyword">if</span> numel(fastaStruct)==1
0610                     fastawrite(fullfile(dataDir,<span class="string">'aligned'</span>,[missingAligned{i} <span class="string">'.faw'</span>]),fastaStruct);
0611                 <span class="keyword">end</span>
0612             <span class="keyword">end</span>
0613             <span class="comment">%Move the temporary file to the real one</span>
0614             movefile(fullfile(dataDir,<span class="string">'aligned'</span>,[missingAligned{i} <span class="string">'.faw'</span>]),fullfile(dataDir,<span class="string">'aligned'</span>,[missingAligned{i} <span class="string">'.fa'</span>]),<span class="string">'f'</span>);
0615         <span class="keyword">end</span>
0616     <span class="keyword">end</span>
0617 <span class="keyword">end</span>
0618 
0619 <span class="keyword">if</span> ~ispc
0620     <span class="keyword">if</span> (seqIdentity==1 || seqIdentity==0.9 || seqIdentity==0.5)
0621         fprintf(<span class="string">'Completed clustering and multiple alignment of sequences\n'</span>);
0622     <span class="keyword">else</span>
0623         fprintf(<span class="string">'Completed multiple alignment of sequences. Protein clustering was not requested or incorrect seqIdentity value was used\n'</span>);
0624     <span class="keyword">end</span>
0625 <span class="keyword">else</span>
0626     <span class="keyword">if</span> (seqIdentity==1 || seqIdentity==0.9 || seqIdentity==0.5)
0627         fprintf(<span class="string">'Protein clustering was skipped, since CD-HIT is not compatible with Windows'</span>);
0628     <span class="keyword">end</span>
0629     fprintf(<span class="string">'Completed multiple alignment of sequences\n'</span>);
0630 <span class="keyword">end</span>
0631 
0632 <span class="comment">%Check if training of Hidden Markov models should be performed</span>
0633 missingHMMs=setdiff(KOModel.rxns,[hmmFiles;outFiles]);
0634 <span class="keyword">if</span> ~isempty(missingHMMs)
0635     missingHMMs=missingHMMs(randperm(RandStream.create(<span class="string">'mrg32k3a'</span>,<span class="string">'Seed'</span>,cputime()),numel(missingHMMs)));
0636     
0637     <span class="comment">%Train models for all missing KOs</span>
0638     <span class="keyword">for</span> i=1:numel(missingHMMs)
0639         <span class="comment">%This is checked here because it could be that it is created by a</span>
0640         <span class="comment">%parallel process</span>
0641         <span class="keyword">if</span> ~exist(fullfile(dataDir,<span class="string">'hmms'</span>,[missingHMMs{i} <span class="string">'.hmm'</span>]),<span class="string">'file'</span>) &amp;&amp; ~exist(fullfile(dataDir,<span class="string">'hmms'</span>,[missingHMMs{i} <span class="string">'.hmw'</span>]),<span class="string">'file'</span>)
0642             <span class="comment">%Check that the aligned FASTA file exists. It could be that it</span>
0643             <span class="comment">%is still being worked on by some other instance of the program</span>
0644             <span class="comment">%(the .faw file should then exist). This should not happen on a</span>
0645             <span class="comment">%single computer. It doesn't throw an error, because it should</span>
0646             <span class="comment">%finalize the ones it can</span>
0647             <span class="keyword">if</span> ~exist(fullfile(dataDir,<span class="string">'aligned'</span>,[missingHMMs{i} <span class="string">'.fa'</span>]),<span class="string">'file'</span>)
0648                 EM=[<span class="string">'The aligned FASTA file for '</span> missingHMMs{i} <span class="string">' does not exist'</span>];
0649                 dispEM(EM,false);
0650                 <span class="keyword">continue</span>;
0651             <span class="keyword">end</span>
0652             
0653             <span class="comment">%If the multi-FASTA file is empty then save an empty aligned</span>
0654             <span class="comment">%file and continue</span>
0655             s=dir(fullfile(dataDir,<span class="string">'aligned'</span>,[missingHMMs{i} <span class="string">'.fa'</span>]));
0656             <span class="keyword">if</span> s.bytes&lt;=0
0657                 fid=fopen(fullfile(dataDir,<span class="string">'hmms'</span>,[missingHMMs{i} <span class="string">'.hmm'</span>]),<span class="string">'w'</span>);
0658                 fclose(fid);
0659                 <span class="keyword">continue</span>;
0660             <span class="keyword">end</span>
0661             <span class="comment">%Create a temporary file to indicate that it is working on the</span>
0662             <span class="comment">%KO. This is because hmmbuild cannot overwrite existing files</span>
0663             fid=fopen(fullfile(dataDir,<span class="string">'hmms'</span>,[missingHMMs{i} <span class="string">'.hmw'</span>]),<span class="string">'w'</span>);
0664             fclose(fid);
0665             
0666             <span class="comment">%Create HMM</span>
0667             [status, output]=system([<span class="string">'&quot;'</span> fullfile(ravenPath,<span class="string">'software'</span>,<span class="string">'hmmer-3.1b2'</span>,[<span class="string">'hmmbuild'</span> binEnd]) <span class="string">'&quot; --cpu &quot;'</span> cores <span class="string">'&quot; &quot;'</span> fullfile(dataDir,<span class="string">'hmms'</span>,[missingHMMs{i} <span class="string">'.hmm'</span>]) <span class="string">'&quot; &quot;'</span> fullfile(dataDir,<span class="string">'aligned'</span>,[missingHMMs{i} <span class="string">'.fa'</span>]) <span class="string">'&quot;'</span>]);
0668             <span class="keyword">if</span> status~=0
0669                 EM=[<span class="string">'Error when training HMM for '</span> missingHMMs{i} <span class="string">':\n'</span> output];
0670                 dispEM(EM);
0671             <span class="keyword">end</span>
0672             
0673             <span class="comment">%Delete the temporary file</span>
0674             delete(fullfile(dataDir,<span class="string">'hmms'</span>,[missingHMMs{i} <span class="string">'.hmw'</span>]));
0675         <span class="keyword">end</span>
0676     <span class="keyword">end</span>
0677 <span class="keyword">end</span>
0678 fprintf(<span class="string">'Completed generation of HMMs\n'</span>);
0679 
0680 <span class="comment">%Check which new .out files that should be generated Check if training of</span>
0681 <span class="comment">%Hidden Markov models should be performed</span>
0682 missingOUT=setdiff(KOModel.rxns,outFiles);
0683 <span class="keyword">if</span> ~isempty(missingOUT)
0684     missingOUT=missingOUT(randperm(RandStream.create(<span class="string">'mrg32k3a'</span>,<span class="string">'Seed'</span>,cputime()),numel(missingOUT)));
0685     <span class="keyword">for</span> i=1:numel(missingOUT)
0686         <span class="comment">%This is checked here because it could be that it is created by a</span>
0687         <span class="comment">%parallel process</span>
0688         <span class="keyword">if</span> ~exist(fullfile(outDir,[missingOUT{i} <span class="string">'.out'</span>]),<span class="string">'file'</span>)
0689             <span class="comment">%Check that the HMM file exists. It should do so since %we are</span>
0690             <span class="comment">%saving empty files as well. Print a warning and continue if</span>
0691             <span class="comment">%not</span>
0692             <span class="keyword">if</span> ~exist(fullfile(dataDir,<span class="string">'hmms'</span>,[missingOUT{i} <span class="string">'.hmm'</span>]),<span class="string">'file'</span>)
0693                 EM=[<span class="string">'The HMM file for '</span> missingOUT{i} <span class="string">' does not exist'</span>];
0694                 dispEM(EM,false);
0695                 <span class="keyword">continue</span>;
0696             <span class="keyword">end</span>
0697             
0698             <span class="comment">%Save an empty file to prevent several threads working on the</span>
0699             <span class="comment">%same file</span>
0700             fid=fopen(fullfile(outDir,[missingOUT{i} <span class="string">'.out'</span>]),<span class="string">'w'</span>);
0701             fclose(fid);
0702             
0703             <span class="comment">%If the HMM file is empty then save an out file and continue</span>
0704             s=dir(fullfile(dataDir,<span class="string">'hmms'</span>,[missingOUT{i} <span class="string">'.hmm'</span>]));
0705             <span class="keyword">if</span> s.bytes&lt;=0
0706                 <span class="keyword">continue</span>;
0707             <span class="keyword">end</span>
0708             
0709             <span class="comment">%Check each gene in the input file against this model</span>
0710             [status, output]=system([<span class="string">'&quot;'</span> fullfile(ravenPath,<span class="string">'software'</span>,<span class="string">'hmmer-3.1b2'</span>,[<span class="string">'hmmsearch'</span> binEnd]) <span class="string">'&quot; --cpu &quot;'</span> cores <span class="string">'&quot; &quot;'</span> fullfile(dataDir,<span class="string">'hmms'</span>,[missingOUT{i} <span class="string">'.hmm'</span>]) <span class="string">'&quot; &quot;'</span> fastaFile <span class="string">'&quot;'</span>]);
0711             <span class="keyword">if</span> status~=0
0712                 EM=[<span class="string">'Error when querying HMM for '</span> missingOUT{i} <span class="string">':\n'</span> output];
0713                 dispEM(EM);
0714             <span class="keyword">end</span>
0715             
0716             <span class="comment">%Save the output to a file</span>
0717             fid=fopen(fullfile(outDir,[missingOUT{i} <span class="string">'.out'</span>]),<span class="string">'w'</span>);
0718             fwrite(fid,output);
0719             fclose(fid);
0720         <span class="keyword">end</span>
0721     <span class="keyword">end</span>
0722 <span class="keyword">end</span>
0723 fprintf(<span class="string">'Completed matching to HMMs\n'</span>);
0724 
0725 <span class="comment">%***Begin retrieving the output and putting together the resulting model</span>
0726 
0727 <span class="comment">%Retrieve matched genes from the HMMs</span>
0728 koGeneMat=zeros(numel(KOModel.rxns),3000); <span class="comment">%Make room for 3000 genes</span>
0729 genes=cell(3000,1);
0730 <span class="comment">%Store the best score for a gene in a hash list (since it will be searching</span>
0731 <span class="comment">%many times)</span>
0732 hTable = java.util.Hashtable;
0733 
0734 geneCounter=0;
0735 <span class="keyword">for</span> i=1:numel(KOModel.rxns)
0736     <span class="keyword">if</span> exist(fullfile(outDir,[KOModel.rxns{i} <span class="string">'.out'</span>]), <span class="string">'file'</span>)
0737         fid=fopen(fullfile(outDir,[KOModel.rxns{i} <span class="string">'.out'</span>]),<span class="string">'r'</span>);
0738         beginMatches=false;
0739         <span class="keyword">while</span> 1
0740             <span class="comment">%Get the next line</span>
0741             tline = fgetl(fid);
0742             
0743             <span class="comment">%Abort at end of file</span>
0744             <span class="keyword">if</span> ~ischar(tline)
0745                 <span class="keyword">break</span>;
0746             <span class="keyword">end</span>
0747             
0748             <span class="keyword">if</span> and(beginMatches,strcmp(tline,<span class="string">'  ------ inclusion threshold ------'</span>))
0749                 <span class="keyword">break</span>;
0750             <span class="keyword">end</span>
0751             
0752             <span class="keyword">if</span> beginMatches==false
0753                 <span class="comment">%This is how the listing of matches begins</span>
0754                 <span class="keyword">if</span> any(strfind(tline,<span class="string">'E-value '</span>))
0755                     <span class="comment">%Read one more line that is only padding</span>
0756                     tline = fgetl(fid);
0757                     beginMatches=true;
0758                 <span class="keyword">end</span>
0759             <span class="keyword">else</span>
0760                 <span class="comment">%If matches should be read</span>
0761                 <span class="keyword">if</span> ~strcmp(tline,<span class="string">'   [No hits detected that satisfy reporting thresholds]'</span>) &amp;&amp; ~isempty(tline)
0762                     elements=regexp(tline,<span class="string">' '</span>,<span class="string">'split'</span>);
0763                     elements=elements(cellfun(@any,elements));
0764                     
0765                     <span class="comment">%Check if the match is below the treshhold</span>
0766                     score=str2num(elements{1});
0767                     gene=elements{9};
0768                     <span class="keyword">if</span> score&lt;=cutOff
0769                         <span class="comment">%If the score is exactly 0, change it to a very</span>
0770                         <span class="comment">%small value to avoid NaN</span>
0771                         <span class="keyword">if</span> score==0
0772                             score=10^-250;
0773                         <span class="keyword">end</span>
0774                         <span class="comment">%Check if the gene is added already and, is so, get</span>
0775                         <span class="comment">%the best score for it</span>
0776                         I=hTable.get(gene);
0777                         <span class="keyword">if</span> any(I)
0778                             koGeneMat(i,I)=score;
0779                         <span class="keyword">else</span>
0780                             geneCounter=geneCounter+1;
0781                             <span class="comment">%The gene was not present yet so add it</span>
0782                             hTable.put(gene,geneCounter);
0783                             genes{geneCounter}=gene;
0784                             koGeneMat(i,geneCounter)=score;
0785                         <span class="keyword">end</span>
0786                     <span class="keyword">end</span>
0787                 <span class="keyword">else</span>
0788                     <span class="keyword">break</span>;
0789                 <span class="keyword">end</span>
0790             <span class="keyword">end</span>
0791         <span class="keyword">end</span>
0792         fclose(fid);
0793     <span class="keyword">end</span>
0794 <span class="keyword">end</span>
0795 koGeneMat=koGeneMat(:,1:geneCounter);
0796 
0797 <span class="comment">%Remove the genes for each KO that are below minScoreRatioKO.</span>
0798 <span class="keyword">for</span> i=1:size(koGeneMat,1)
0799     J=find(koGeneMat(i,:));
0800     <span class="keyword">if</span> any(J)
0801         koGeneMat(i,J(log(koGeneMat(i,J))/log(min(koGeneMat(i,J)))&lt;minScoreRatioKO))=0;
0802     <span class="keyword">end</span>
0803 <span class="keyword">end</span>
0804 
0805 <span class="comment">%Remove the KOs for each gene that are below minScoreRatioG</span>
0806 <span class="keyword">for</span> i=1:size(koGeneMat,2)
0807     J=find(koGeneMat(:,i));
0808     <span class="keyword">if</span> any(J)
0809         koGeneMat(J(log(koGeneMat(J,i))/log(min(koGeneMat(J,i)))&lt;minScoreRatioG),i)=0;
0810     <span class="keyword">end</span>
0811 <span class="keyword">end</span>
0812 
0813 <span class="comment">%Create the new model</span>
0814 model.genes=genes(1:geneCounter);
0815 model.grRules=cell(numel(model.rxns),1);
0816 model.grRules(:)={<span class="string">''</span>};
0817 model.rxnGeneMat=sparse(numel(model.rxns),numel(model.genes));
0818 
0819 <span class="comment">%Loop through the reactions and add the corresponding genes</span>
0820 <span class="keyword">for</span> i=1:numel(model.rxns)
0821     <span class="keyword">if</span> isstruct(model.rxnMiriams{i})
0822         <span class="comment">%Get all KOs</span>
0823         I=find(strcmpi(model.rxnMiriams{i}.name,<span class="string">'kegg.orthology'</span>));
0824         KOs=model.rxnMiriams{i}.value(I);
0825         <span class="comment">%Find the KOs and the corresponding genes</span>
0826         J=ismember(KOModel.rxns,KOs);
0827         [~, K]=find(koGeneMat(J,:));
0828         
0829         <span class="keyword">if</span> any(K)
0830             model.rxnGeneMat(i,K)=1;
0831             <span class="comment">%Also delete KOs for which no genes were found. If no genes at</span>
0832             <span class="comment">%all were matched to the reaction it will be deleted later</span>
0833             L=sum(koGeneMat(J,:),2)==0;
0834             model.rxnMiriams{i}.value(I(L))=[];
0835             model.rxnMiriams{i}.name(I(L))=[];
0836         <span class="keyword">end</span>
0837     <span class="keyword">end</span>
0838 <span class="keyword">end</span>
0839 
0840 <span class="comment">%Find and delete all reactions without any genes. This also removes genes</span>
0841 <span class="comment">%that are not used (which could happen because minScoreRatioG and</span>
0842 <span class="comment">%minScoreRatioKO)</span>
0843 I=sum(model.rxnGeneMat,2)==0;
0844 model=removeReactions(model,I,true,true);
0845 
0846 <span class="comment">%Add the gene associations as 'or'</span>
0847 <span class="keyword">for</span> i=1:numel(model.rxns)
0848     <span class="comment">%Find the involved genes</span>
0849     I=find(model.rxnGeneMat(i,:));
0850     model.grRules{i}=[<span class="string">'('</span> model.genes{I(1)}];
0851     <span class="keyword">for</span> j=2:numel(I)
0852         model.grRules{i}=[model.grRules{i} <span class="string">' or '</span> model.genes{I(j)}];
0853     <span class="keyword">end</span>
0854     model.grRules{i}=[model.grRules{i} <span class="string">')'</span>];
0855 <span class="keyword">end</span>
0856 
0857 <span class="comment">%Fix grRules and reconstruct rxnGeneMat</span>
0858 [grRules,rxnGeneMat] = standardizeGrRules(model,false); <span class="comment">%Give detailed output</span>
0859 model.grRules = grRules;
0860 model.rxnGeneMat = rxnGeneMat;
0861 <span class="keyword">end</span>
0862 
0863 <span class="comment">%Supporter function to list the files in a directory and return them as a</span>
0864 <span class="comment">%cell array</span>
0865 <a name="_sub1" href="#_subfunctions" class="code">function files=listFiles(directory)</a>
0866 temp=dir(directory);
0867 files=cell(numel(temp),1);
0868 <span class="keyword">for</span> i=1:numel(temp)
0869     files{i}=temp(i,1).name;
0870 <span class="keyword">end</span>
0871 files=strrep(files,<span class="string">'.fa'</span>,<span class="string">''</span>);
0872 files=strrep(files,<span class="string">'.hmm'</span>,<span class="string">''</span>);
0873 files=strrep(files,<span class="string">'.out'</span>,<span class="string">''</span>);
0874 files=strrep(files,<span class="string">'.faw'</span>,<span class="string">''</span>);
0875 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Wed 22-Aug-2018 16:19:49 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>